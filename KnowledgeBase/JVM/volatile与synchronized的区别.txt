# 问题：volatile与synchronized的区别？
答案：这个问题可以从Java内存模型方面来回答，Java内存模型主要是围绕在并发过程中如何处理原子性，可见性，有序性这三个特征来建立的。volatile关键字可以保证线程间变量的可见性，还有包含了禁止指令重排序的语义，满足了有序性。synchronized关键字原子性（排它锁），可见性，有序性都可以满足。因此它们的区别就在于原子性了。
PS：上述特性可以从先行发生happens-before原则在来解释一下。先行发生是Java内存模型中定义的两项操作的偏序关系。第三条，volatile变量规则：对一个volatile变量的写操作先行发生于读操作。满足可见性。第二条，管程锁定原则：一个unlock先行发生于同一个锁的lock。满足有序性。



synchronized


如果CAS获取偏向锁失败，则表示有竞争（CAS获取偏向锁失败说明至少有过其他线程曾经获得过偏向锁，因为线程不会主动去释放偏向锁）。
当到达全局安全点（safepoint）时，会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着（因为可能持有偏向锁的线程已经执行完毕，
但是该线程并不会主动去释放偏向锁），如果线程不处于活动状态，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；
如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，
而正在竞争的线程会进入自旋等待获得该轻量级锁。


偏向锁使用了一种等到竞争出现才释放偏向锁的机制：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，
线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，
判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。


