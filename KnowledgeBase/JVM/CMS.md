服务端一般使用ParNewGC(Young)+ConcMarkSweepGC(Old)组合来使用。
	
	-XX:+UseParNewGC -XX:+UseConcMarkSweepGC
	
CMS特点：
	
	1.年老代
	2.并发收集，低停顿
	3.标记-清除
	
整个过程过程分为4步骤：
	
	1.initial mark：标记GC Roots直接关联到的对象，[STW]
	2.concurrent mark：标记整个引用链，[并发执行]
	3.remark：重新标记并发标记阶段因用户线程继续运行而产生的对象的变动，[STW]
	4.concurrent sweep：并发清理阶段，主要工作是 清理所有未被标记的死亡对象，回收被占用的空间，[并发执行]
	
# 为何CMS是低停顿？

CMS在老年代的收集主要分为4步，初始标记，并发标记，重新标记，并发清除，时间耗费主要花费在2、4步，而2、4步正好是并发执行，也就是用户线程与GC线程并发执行，所以说CMS是低停顿。

# 解决CMS并发清理产生的内存碎片问题

CMS默认开启-XX:+UseCMSCompactAtFullCollection，用于在FullGC之前内存整理

# CMS与Serial Old思路问题

这两个GC都是工作在老年代，Serial Old采用"一刀切"的方式直接停下所有用户线程，一步到位，标记，整理，然后GC结束，恢复用户线程，导致停顿时间长。
而CMS换了个思路，开始分步骤执行，初始标记，速度快，虽然STW，但是不影响；并发标记，标记的工作的主要大头在这里，顺着GC Roots标记整个引用链，时间长，速度慢，这里设计成并发执行；重新标记，标记并发标记期间部分变动的对象，速度快，虽然STW，但是不影响；最后一步，并发清除，清除工作的主要大头在这里，也设计成了并发执行。因此，纵观整个过程，CMS将减少停顿时间做到了极值，因此达到了设计目标：减少停顿时间。

同样都是GC，我发现其中最重要的不同是在于<任务分解，并发执行>，来提高效率。

由此，我有联想到了Hashtable与ConcurrentHashMap的区别，同样是线程安全，为何会有很大的不同，我的理解也是<任务分解，并发执行>

拿put(Key, Value)来说，Hashtable采用"一刀切"的方式停下了所有与它竞争的线程，单线程执行put，数组扩容，重新放入数组等一系列操作，自己完成后，其它线程开始竞争执行，缺点就是停顿时间长，时间耗费最长的莫过于数据扩容，将元素重新放入新数组中了。

而，ConcurrentHashMap采用任务分解的方式，当线程发现数组在扩容，他就会过来helps transfer，帮助转换，ConcurrentHashMap将整个扩容操作分解为多线程可以参与的并发任务，大大缩短了扩容时间。一个人干总没有多个人干要快吧，当然任务要合理分配，要不然非要打起来不可。

综上所述，CMS之于Serial Old，就如同Hashtable与ConcurrentHashMap，当前是个并发的时代。







