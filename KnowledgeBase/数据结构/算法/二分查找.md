
二分查找的前提是有序

例如 [1, 3, 4, 6, 7, 9, 11, 14, 16, 78] 中查找{ 14 }是否存在

第一种思路：花费O(n)时间复杂度，可以统计下标，重复元素个数等等信息，优点是编程思路简单。缺点是不够高效，是因为它忽略了排序的特性，没有从这方面入手。

第二种思路：利用二分查找的思路，每次减半到N/2，这是分而治之的思想，整体时间复杂度为O(log n)



思考：
如果给出的数组中乱序怎么办呢？
1.可以全部遍历，花费O(n)
2.先排序，在二分，花费O(nlogn) + O(logn)




