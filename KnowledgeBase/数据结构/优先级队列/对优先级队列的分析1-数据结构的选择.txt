kb_time_20200131
kb_abstract_对优先级队列的分析1-数据结构的选择
kb_tag_PriorityQueue

最基础的数据结构是数组与链表，在此基础上扩展了许多高级的数据结构。

优先级队列就是按照一定的顺序出队的队列，包括后进先出的栈（后进的元素优先级高），先进先出的队列（先进的元素优先级高），最大堆（值大的元素优先级高），
最小堆（值小的元素优先级高）。在Java中，java.util.PriorityQueue<E>专指的是最大堆或最小堆。

优先级队列作为一种高级的数据结构，底层使用不同的实现方式会带来不同的实现效率。

首先列出PriorityQueue接口定义：
	
	public interface PriorityQueue<E>{//这里以最大堆为例
		
		E getMax();
		E deleteMax();
		void insert(E element);
	}
	
接下来分析使用不同的底层数据结构会带来什么样的效率：
1.无序数组
	getMax - O(n) - 需要遍历整个数组来查找最大值
	deleteMax - O(n) - 最坏花费O(n)的时间查找，花费O(n)的时间来移动后续的元素
	insert - O(1) - 直接插入到最后一个位置 - <readme:数组插入元素都会设计到数组扩容问题:递增式扩容与加倍式扩容>
2.有序数组：将数组变为有序，就不需要每次遍历来查找和删除最大值了
	getMax - O(1) - 数组的末尾
	deleteMax - O(1) - 数组的末尾，而是不涉及移动元素 - <readme:数组必须为递增的原因就在这里>
	insert - O(n) - 使用二分法找到位置，插入元素移动后续元素，O(log n) + O(n)，花费O(n)的时间
3.无序链表（双链表和单链表都可以，其实单链表已经能满足要求了）
	getMax - O(n) - 需要遍历整个链表来查找最大值
	deleteMax - O(n) - 最坏花费O(n)的时间查找，花费O(1)的时间来移动后续的元素
	insert - O(1) - 直接插入到最后一个位置 - <readme:这也是链表作为动态存储结构的好处了>
4.有序链表：无所谓递增与递减
	getMax - O(1) - 如果递增，链表的末尾
	deleteMax - O(1) - 如果递增，链表的末尾
	insert - O(n) - 最坏花费O(n)的时间查找位置，花费O(1)的时间来插入元素
5.平衡二叉搜索树BBST：杀鸡用牛刀，我们只需要满足偏序就行，BBST则是全排序，在维护全排序的同时带来的是很多复杂度
	getMax - O(log n) - 顺着根节点的右子树遍历，花费树高度的复杂度，也就是O(log n)
	deleteMax - O(log n) - 查找需要O(log n)，删除需要常数时间复杂度
	insert - O(log n) - 花费树高度的复杂度，也就是O(log n)
6.完全二叉堆：既可以快速找到极值，还维护的是偏序姓(堆序性)，很好的满足了我们的需求
	getMax - O(1) - 数组的首元素
	deleteMax - O(log n) - 数组的首元素与末元素交换，将末元素抹除，执行首元素的下滤操作
	insert - O(log n) - 插入数组末尾，执行末元素的上滤操作 - <readme:数组扩容策略一般使用2倍，1.5倍扩容>

结论：
使用完全二叉堆作为优先级队列的底层数据结构是最合适不过了。我的想法是并不是优先级队列的数据结构必须是完全二叉堆，而是因为完全二叉堆适合优先级队列的场景，
所以我们选择了它，从1到6，不同的数据结构的选择与分析破除了我对很多东西神化的想法，原来这些东西不是理所当然，而是适当选择的。

PS：
数组为形，完全二叉树为神，是为完全二叉堆也。







