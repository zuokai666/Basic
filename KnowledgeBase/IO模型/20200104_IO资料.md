# IO模型补充资料

一 内核空间、用户空间、系统调用的概念
	操作系统为了确保自己的内核程序运行的安全,以及防止用户进程直接访问硬件造成破坏,把进程空间分为用户空间和内核空间,系统程序运行在内核空间,用户进程只能运行在用户空间里,并且不能直接访问硬件,需要通过系统调用,从而执行操作系统提供的相关程序(可执行cpu的特权指令)间接地访问硬件.

二 用户进程的IO过程
	当一个用户进程需要从硬盘的文件中读取数据时,需要执行系统调用open打开文件,操作系统要做的操作是在内核空间创建一个结构体,结构体中存有文件的信息以及包含有存放数据的缓冲区,然后将这个结构体的地址作为文件句柄(FileDescriptor, 下面简称FD)返回给用户进程.
	用户进程获取到文件的句柄后,可以执行IO读写操作相关的系统调用,如read/write系统调用.例如,当用户进程执行read系统调用时,系统通过硬盘驱动程序的读指令向硬件发送读数据的命令,将外存的数据搬进内核缓冲区(这个过程的低层实现就是本系列第一篇文章中介绍的DMA方式了),然后再把内核缓冲区的数据搬到用户区.反之,write系统调用时,系统会将用户区的数据先搬到内核缓冲区,然后再将其搬往外存.
	硬盘 -> 内核空间 -> 用户空间
	硬盘 <- 内核空间 <- 用户空间
三 操作系统级别的5种IO模型
1 阻塞式IO
	最普通的I/O模型;原生的read/write系统调用，默认是阻塞模式；导致进程阻塞在read/write系统调用直到IO完成
2 非阻塞IO
	这种方式通过指定系统调用read/write的参数为非阻塞，告知内核IO没就绪时，不阻塞进程，而是返回一个错误码，应用进程死循环轮询，直到IO就绪,注意IO就绪后进程仍要阻塞以等待内核缓冲区的数据拷备到用户区(读)或反之(写),只是等待IO就绪的阶段,进程不用阻塞在read/write系统调用,而是要对IO是否就绪状态进行轮询.
3 I/O复用
	如linux系统提供的select/poll，进程通过将一个或多个FD传递给select或poll系统调用，阻塞在select系统调用,而不需要请求进程自己轮询IO状态;这样select/poll可以帮我们侦测许多fd是否就绪；当操作系统的select调用侦测到某些FD对应的IO就绪后,进程不再在Select调用阻塞,而是可以开始IO操作,在IO操作过程中("真正"的读或写)进程仍然阻塞在read/write系统调用以等待内核缓冲区的数据拷备到用户区(读)或反之(写)
4 信号驱动式I/O
	请求进程可以通过系统调用向系统发送想要进行IO操作的信号,这个过程不阻塞,内核在FD描述符就绪时发送SIGIO信号通知回请求的进程，告知请求进程IO操作已就绪. 进程通过信号处理函数接收数据,接收数据时,仍要阻塞在read/write系统调用,以等待内核缓冲区与用户缓冲区之间的数据拷备；
5 异步I/O（AIO)
	通过系统调用告知内核某个IO操作并立即返回，并让内核自动进行整个IO操作,包括将数据复制到用户的进程缓冲区(读)或反之(写),完成后再通知用户进程。这种模型和信号驱动式I/O模型区别在于：信号驱动式I/O由内核通知我们何时可以启动一个I/O操作，而异步I/O模型是内核通知我们I/O操作何时完成。整个IO过程中,请求进程都不用阻塞.
	

1 阻塞式IO 就好比java.util.concurrent.locks.Lock.lock()操作一样
2 非阻塞IO 就好比java.util.concurrent.locks.Lock.tryLock()操作一样




















