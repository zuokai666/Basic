# 页面置换算法之LRU

##### 现实场景

我们平时生活和工作中会看很多书籍，我的书籍存放于一个箱子中，里面有很多东西，比如报纸，技术图书，杂志等等，我每次看书都很费劲，因为书籍有常看的，也有不经常看的，混在一起不好找，所以我就打算将经常看的书籍放到书桌上，离我又近，查找还方便。由于没有书立，所以我就上下叠放书籍。其次，书桌上的书籍总要有个数量限制，我设置为最多放5本。

箱子中的东西：（杂乱无章，没有顺序）
	
	《镇江日报》	《河池日报》
	《闽南日报》	《成都商报》
	《杭州日报》	《浙江日报》
	《深入理解Java虚拟机:第三版》	《Java并发编程》
	《MySQL技术内幕 InnoDB存储引擎》	《Redis设计与实现》
	《JVM G1源码分析和调优》	《Spring技术内幕》
	《Redis深度历险：核心原理与应用实践》	《myBatis技术内幕》
	《重新定义Spring Cloud实战》	《深入拆解Java虚拟机》
	《读者》	《意林》	《青年文摘》
	
书桌上的书籍暂时没有书籍。

2020年1月1日，我要看《深入理解Java虚拟机:第三版》，首先查找书桌上的书籍，发现没有命中，然后我去箱子里查找并且找到了。一顿学习之后，我将书籍放到了书桌上。然后，我又想看《Java并发编程》，和上述步骤相同。然后，我又想看《MySQL技术内幕 InnoDB存储引擎》，和上述步骤相同。然后，我又想看《Spring技术内幕》，和上述步骤相同。然后，我又想看《myBatis技术内幕》，和上述步骤相同，今天学习不错，一共学习了5本书。这时，书桌上的状态：
	
	《myBatis技术内幕》
	《Spring技术内幕》
	《MySQL技术内幕 InnoDB存储引擎》
	《Java并发编程》
	《深入理解Java虚拟机:第三版》
	
2020年1月2日，我要看《深入理解Java虚拟机:第三版》，首先查找书桌上的书籍，找到了，我发现它在最下面，费力的将它抽出来，一顿学习之后，心满意足的结束了今天的学习，最后将书籍放入了最上面。这时，书桌上的状态：
	
	《深入理解Java虚拟机:第三版》
	《myBatis技术内幕》
	《Spring技术内幕》
	《MySQL技术内幕 InnoDB存储引擎》
	《Java并发编程》
	
2020年1月3日，今天心情不佳，想看杂志《读者》，首先查找书桌上的书籍，发现不仅没有找到，而且书桌上的书籍达到了最大量，5个。这个时候我就需要舍弃一本书来换我想要看的，那我就选择最下面一本书吧，它是最近最少看的书，说明我读它的次数少，将它放回箱子不亏。然后我将《Java并发编程》放回了箱子，拿着《读者》，一顿赏心悦目后，结束了今天的读书之旅。这时，书桌上的状态：
	
	《读者》
	《深入理解Java虚拟机:第三版》
	《myBatis技术内幕》
	《Spring技术内幕》
	《MySQL技术内幕 InnoDB存储引擎》
	
经过很长时间，我发现了这里面的操作规律，也就那么几种。
	
	1.当书桌上命中到图书时，将它抽出来，放到最上层。
	2.当书桌上没有命中图书时，还要判断是否达到最大数量：
		2.1.如果没有达到最大数量，将箱子里的书籍放入书桌最上层。
		2.2.如果达到最大数量，将最下层书籍放回箱子，将箱子里的书籍放入书桌最上层。
		
总结：
	
	我为什么要将刚看过的书籍放入最上层呢？
	因为我觉得刚看的书籍是常看书籍，越是常看，越放到最上面，可以减少我去箱子翻书的次数，能提高我阅读书籍的命中率。
	
##### 名词概念

Least Recently Used，即最近最少使用，它是一种常用的页面置换算法。目的是可以提高页面的命中率。

##### 场景分析

箱子即为硬盘，存储容量大，但是访问速度慢。

书桌即为内存，存储容量小，但是访问速度快。

因为内存容量 < 硬盘容量，所以不能缓存所有的页，一旦出现内存达到最大量，就需要选择合适的算法来置换页面。

由于没有书立，我采用栈式存储书籍。由于我可以从中间访问书籍，并将其抽出重新入栈，所以严格意义，这是一个特殊的栈。

果然，程序的世界中没有什么是加中间层解决不了的问题，如果有，那就加两层。

##### 置换策略："时间" <---> "Time"

我认为一本书被我访问的时间越近我就分为常用书籍。

##### 相似场景
	
	1.MySQL的内存缓存硬盘中的数据页，索引页等等
	2.微信，QQ及时聊天APP首页的聊天记录，假设只能放N个聊天记录，它认为我最新聊天的人或者群放到最上层。
	当我们从聊天记录中找不到人时，就是联系人中找他聊天，这个时候将最新的人的聊天放入栈首，栈尾删除，这也是LRU策略。
	可惜微信，QQ没有限制，这就有点尴尬了，但不妨碍原理介绍。
	
##### LRU缺点

如果按照时间来分类书籍的话，会有一种问题。我是一个程序员，注定一年365天大多数都在看技术书籍，但是有几次我对国家大事比较关注，我就翻到了箱子里面的所有报纸来看，结果我就看了几天。这时，书桌上的状态：
	
	《镇江日报》
	《河池日报》
	《闽南日报》
	《成都商报》
	《杭州日报》

可以看到按照时间分类的缺点是偶发性大规模的不常用的书籍阅读会将我作为程序员经常阅读的技术书籍全部置换到了箱子中，这会导致后面我阅读技术书籍命中率为0，这不是我想要的，俗称"污染缓存"。

##### 解决方案

1.MySQL InnoDB存储引擎对LRU的优化

在InnoDB的存储引擎中，LRU列表加入了midpoint位置。新读取到的页，虽然是最新访问的页，但是并不直接加入LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法称为"midpoint inserting strategy"。

midpoint位置可以由参数innodb_old_blocks_pct控制，默认37，即列表的37%的位置。

在InnoDB中，把midpoint之前的列表称为new列表，之后的列表称为old列表，可以简单的理解为new列表中的页都是最为活跃的热点数据。

如果上面的我的书籍置换策略优化成这样，可以在一定程度上避免"污染缓存"，在偶发性的大规模阅读不常用的书籍之后也可以拥有不错的页面命中率。

2.LRU-K

LRU-K K代表最近使用的次数,因此LRU也可以认为是LRU-1,它主要是为了解决LRU算法"缓存污染"的问题,其核心思想是将"最近使用过1次"的判断标准扩展为"最近使用过K次"; 相比LRU要多维护一个队列,用于记录所有缓存数据被访问的历史,只有当数据的访问次数达到K次的时候,才将数据放入缓存.当需要淘汰数据时,LRU-k会淘汰第K次访问时间距离当前时间最大的数据.详细实现如下:

	一,数据第一次被访问,加入到访问历史列表; 
	二,如果数据在访问历史列表里后达到K次访问,则按照一定(FIFO, LRU)淘汰; 
	三,当访问历史队列中的数据访问次数达到k次后,将数据l索引从历史队列删除,将数据移到缓存队列中,并缓存此数据,缓存队列重新按照时间排序; 
	四,缓存数据队列中被再次访问后,重新排序; 
	五,需要淘汰数据时,淘汰缓存队列中排在末尾的数据(即:淘汰倒数第K次访问离现在最久的数据)
	
	优缺点：
	优点：LRU-K具有LRU的优点,同时能够避免LRU的缺点,降低了"缓存污染"带来的问题,命中率比LRU要高,
	实际应用中LRU-2是综合各种因素后最优的选择,LRU-3或者更大的K值命中率会高,但适应性差,需要大量的数据访问才能将历史记录缓存或者清除掉
	
	缺点：LRU-K队列是一个优先级队列,算法复杂度和代价相对LRU较高,并且LRU需要记录那些被访问过,
	但是没有达到K次也就是还没有放入缓存的对象,因此b内存消耗会比LRU要多,当然如果数据量很大的时候,内存消耗会比较可观。






