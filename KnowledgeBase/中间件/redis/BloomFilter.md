Bloom Filter:二进制向量与随机映射函数

问题：如果我们想要判断一个元素是否在集合中，我们会怎么做？

1.从最基本数据结构数组与链表开始。首先需要花费O(n)空间来保存元素集合，然后花费O(n)时间来遍历集合。

2.优化，可以使用有序数组，就可以使用二分查找O(log n)的时间来查找到元素

3.接下来使用一些高级数据结构，HashMap（数组+单链表），使用散列函数计算桶位置，平均花费O(1)时间来插入和查找。

4.TreeMap（红黑树），使用O(log n)时间来插入和查找，不如HashMap要好。

以上4种方案的共同点是需要将元素预先放入集合中，如果数据量巨大，就会导致内存吃不消。接下来讨论一下Bloom Filter，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。用于证明：某样东西一定不存在或者可能存在。

首先，第一步，使用n个不同的散列函数计算出n个hash值，将这些位置置为1，标记该元素放入桶内。当查询时，计算n个位置，如果有一个为0，证明一定不存在；如果都是1，则可能存在。
至于删除操作，不支持，因为这个位置是共有的，会有很多元素设置该位置；如果想要支持就需要将原来计入0/1布尔值的方式计入计数统计。就好比，AQS，排它锁重入时将state自增。
这样以空间为代价换来删除操作。

影响BloomFilter的因素：长度与散列函数

布隆过滤器越长其误报率越小，但占用空间增大。
哈希函数的个数越多其误报率越小，但效率会变低。


